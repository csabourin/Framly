You can make “insert DOM objects” feel like “drawing” by separating the UX into two phases:

a pure drawing illusion on a transparent overlay,

a smart commit that converts the drawn box into a real element and inserts it where it belongs.

Here’s the pattern that works well in React/TS with your stack.

1) Draw on a glass overlay (no DOM mutation yet)

Add a full-canvas overlay layer (position:absolute; inset:0; pointer-events:auto) that only exists while the “Draw” tool is active.

On pointerdown, record start and call e.currentTarget.setPointerCapture(e.pointerId).

On pointermove, update a “ghost rect” (rubber-band) in local screen coords. Do not touch the document tree yet.

On pointerup, release capture and “commit” (see #2).

Tiny component sketch:

function DrawingOverlay({ onCommit }: { onCommit: (rect: DOMRect) => void }) {
  const [drag, setDrag] = useState<{start:{x:number;y:number}, curr:{x:number;y:number}}|null>(null);

  const onDown = (e: React.PointerEvent) => {
    e.currentTarget.setPointerCapture(e.pointerId);
    const p = { x: e.clientX, y: e.clientY };
    setDrag({ start: p, curr: p });
  };
  const onMove = (e: React.PointerEvent) => {
    if (!drag) return;
    setDrag({ ...drag, curr: { x: e.clientX, y: e.clientY }});
  };
  const onUp = (e: React.PointerEvent) => {
    if (!drag) return;
    const { start, curr } = drag;
    const left = Math.min(start.x, curr.x);
    const top = Math.min(start.y, curr.y);
    const width = Math.abs(curr.x - start.x);
    const height = Math.abs(curr.y - start.y);
    setDrag(null);
    if (width > 2 && height > 2) onCommit(new DOMRect(left, top, width, height));
  };

  return (
    <div
      className="absolute inset-0 z-[1000] cursor-crosshair"
      onPointerDown={onDown} onPointerMove={onMove} onPointerUp={onUp}
    >
      {drag && (
        <div
          className="absolute border-2 border-dashed"
          style={{
            left: Math.min(drag.start.x, drag.curr.x),
            top: Math.min(drag.start.y, drag.curr.y),
            width: Math.abs(drag.curr.x - drag.start.x),
            height: Math.abs(drag.curr.y - drag.start.y),
          }}
        />
      )}
    </div>
  );
}


Nice touches:

Shift = constrain to square, Alt/Option = draw from center.

Snap the ghost to your grid/guide lines while dragging (don’t commit yet).

Show live blue guides when edges align with sibling edges.

2) Commit by hit-testing + heuristics

When the user releases the mouse, convert the screen-space rect into your canvas coordinate system and choose an insertion target with a few rules:

Hit-test algorithm

Find all containers under the rect’s center (or the greatest overlap) using elementsFromPoint.

Filter to containers that accept children (based on your element schema) and are not locked/instance-readonly.

Prefer the deepest container whose layout can host the new element (e.g., flex/flow/absolute).

Placement heuristics inside the target

If target is absolute/stacking: place at exact (x,y) relative to target’s content box.

If target is flex/flow: compute overlap of the rect’s leading edge with siblings’ bounding boxes and choose the insertion index that minimizes distance. (If the rect spans >60% of a row/column, treat it as “new row/column start”.)

If the rect crosses a child by >70% of its area and the child is a container, descend and try again (natural “draw inside” feeling).

Insertion with animation

Create the new element off-screen as “pending”, then:

Place a morphing ghost in the overlay exactly where the rubber-band was.

Insert the real element in the DOM at its computed final position with zero size and opacity 0.

Read its final box (getBoundingClientRect()), then animate the ghost to that box (200–250ms ease-out).

At the end of the animation, fade in the real element, remove the ghost.
This animation makes it feel like the thing you drew snapped into the layout rather than “teleported”.

Class-first styling

On commit, generate a CSS class (your system already does this) that encodes width/height when absolute, or typical defaults when flow (e.g., w-[calc(var(--snap)*N)] if you quantize to grid). Avoid inline styles to keep your class-first rule.

Pseudo-commit:

function commitDrawnRect(screenRect: DOMRect) {
  const canvas = getCanvasElement(); // your root
  const canvasRect = canvas.getBoundingClientRect();
  const local = new DOMRect(
    screenRect.left - canvasRect.left,
    screenRect.top - canvasRect.top,
    screenRect.width,
    screenRect.height
  );

  const target = chooseTargetContainer(screenRect);
  const { insertionIndex, localXY } = computePlacement(target, screenRect, local);

  const elementDef = {
    type: "rectangle",
    classes: generateClassesForNewElement({ target, localXY, size: local }),
    // no inline styles
  };

  animateMorphFromOverlayToFinal(target, insertionIndex, elementDef, local);
}

3) Make it feel like a drawing tool

Latency budget: no DOM writes until pointerup. This keeps the drag buttery smooth.

Rubber-band cursor: crosshair cursor + dashed outline + light fill (8–12% opacity) sells the drawing illusion.

Edges snap: when the ghost nears grid/guides/siblings, show magnetic ticks. This replaces your current “before/inside/after” badges during drawing.

Tool modality: a big “Draw Rectangle” (R) tool toggles the overlay. Escape cancels.

Pressure/tilt support (if you want stylus polish): record e.pressure to vary guide brightness (purely cosmetic).

4) Optional: hybrid modes

Quick-Absolute: hold ⌘/Ctrl while drawing to force absolute positioning even in a flow container.

Auto-Containerization: if the drawn rect covers multiple siblings in a flow, offer “Wrap in container?” chip; on accept, create a new container and move intersecting siblings inside, then add the new rect.

5) Accessibility & persistence

Announce “Drawing started/ended” via ARIA live when accessibility mode is on.

Persist the last used tool and snapping prefs in IndexedDB.

Undo/redo: the entire commit is a single history step; dragging itself creates no history spam (you already have smart debouncing—reuse that).