Components: product + engineering spec
0) Quick UI bug (Create Component button)

The [Create component] button is visually clipped.
Fix: ensure its parent does not clip:

.components-header { position: relative; overflow: visible; }
.create-component-btn { position: absolute; right: 12px; top: 8px; z-index: 10; }


If a container up the tree has overflow:hidden, scope it or move the button into a non-clipping header.

1) User goals (summary)

Create a component from a selected element (and all descendants).

Store components in categories; category names are persistent (IndexedDB).

The selected element becomes a component instance (locked for direct edits).

Double-click an instance to open component edit mode in a new tab; edits there don’t affect the main canvas until saved/closed.

Save/close updates the component definition and propagates to all instances on the canvas.

Detach converts an instance back to normal, independent elements.

2) Data model
type NodeId = string;
type ComponentId = string;
type CategoryId = string;

interface CanvasNode {
  id: NodeId;
  type: string;                       // 'div','image','text', etc.
  props: Record<string, any>;         // attributes, styles, dataset
  children: NodeId[];                 // normal nodes only (not for component instances)
  componentRef?: {                    // present iff this node is an instance
    componentId: ComponentId;
    overrides?: Record<string, any>;  // (optional future) per-instance prop overrides
  };
}

interface ComponentDef {
  id: ComponentId;
  name: string;
  categoryId: CategoryId | null;
  template: CanvasNode;               // normalized root node (full subtree)
  version: number;
  updatedAt: number;
}

interface ComponentCategory {
  id: CategoryId;
  name: string;
  sortIndex: number;
  createdAt: number;
}

IndexedDB schema (v1)

DB name: builder-db | store names: componentCategories, components

componentCategories keyPath: id

components keyPath: id, index on categoryId

3) Persistence (must)

Categories are persisted in IndexedDB and loaded at app init.

Components are persisted in IndexedDB (definition + version).

On save, bump version and updatedAt.

(You can use idb/Dexie or raw IndexedDB; up to you.)

4) Core flows
4.1 Create component (from selection)

Preconditions: an element is selected on the canvas; selection includes all descendants.

Steps:

Read the current selection’s subtree → template.

Prompt for component name and category (default to “Uncategorized”).

Persist new ComponentDef in IndexedDB.

Replace the selected node with a component instance:

New node keeps the original id but sets:

node.componentRef = { componentId: newComponent.id }
node.children = []; // instances don’t own real children; rendering expands from template


Mark the instance non-editable in the main canvas (see State/UX below).

Update the Components panel list.

Acceptance:

The canvas shows the same visuals as before (the instance renders the template).

Node is locked for single-click edits; double-click opens edit mode.

4.2 Instance behavior on the canvas

Instances are selectable and movable (layout) but not directly editable.

Single click: select instance (show instance chrome).

Double-click: open component edit tab (see 4.3).

Context menu: Detach, Go to definition, Rename component (acts on def), Change category.

CSS / state:

.block[data-instance="true"] { /* read-only visuals */
  outline: 1px dashed var(--token-muted);
}
.block[data-instance="true"][data-state="selected"]::after {
  background: color-mix(in oklab, var(--token-accent), transparent 88%);
}

4.3 Component edit mode (tabbed)

Uses existing tabbing system. Each open component shows as a tab (title = component name).

When a component tab is active:

Render the component template into an isolated editing canvas (not the main canvas).

All nodes are editable as usual.

Main canvas is not interacted with (no selection/drag in main canvas while the component tab is focused).

Enter mode: double-click an instance or choose “Edit component” in the panel.
Exit mode: Close the tab or click Save.

Save/close behavior (both):

Serialize current template → write to components store.

Increment version, update updatedAt.

Propagate to main canvas: re-render all instances (see 4.4).

Close the tab (if closing) and return focus to the previously selected instance on the main canvas.

Unsaved changes guard:

If there are edits, show a confirm dialog on close.

4.4 Propagation to all instances

Render strategy:

Maintain an in-memory cache componentMap: Map<ComponentId, ComponentDef>.

When rendering an instance, deep-clone componentMap.get(id).template into a virtual tree and mount under the instance’s DOM, applying any instance overrides (if implemented later).

On save/close of component tab:

Update componentMap and instruct the main canvas to re-render all nodes where node.componentRef.componentId === savedId.

For performance, keep an index of instance node ids per componentId.

4.5 Detach instance

Action: Detach (from context menu or panel).

Replace the instance node with a deep clone of the latest component template as regular nodes:

Remove componentRef from the node.

Insert children from the cloned template.

After detach, the subtree is fully independent and editable on the main canvas.

Acceptance:

Visuals unchanged.

Editing now works inline (no double-click needed).

The detached subtree no longer updates when the component definition changes.

5) UI & interactions
5.1 Components panel (left rail)

Shows Search, Categories (persisted), and list of components.

Add Category: inline field → persist to IndexedDB immediately.

Reorder categories by drag; update sortIndex.

5.2 Create Component button

Enabled if a selection exists; otherwise disabled.

On click → run Create component flow (4.1).

5.3 Instance chrome and affordances

Single click selects.

Double-click → opens tab to edit definition.

Tooltip: “Double-click to edit component definition”.

Context menu: Edit, Detach, Rename, Change Category, Reveal in Panel.