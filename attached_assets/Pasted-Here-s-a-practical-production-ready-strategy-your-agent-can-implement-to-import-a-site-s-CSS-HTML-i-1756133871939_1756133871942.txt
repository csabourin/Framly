Here’s a practical, production‑ready strategy your agent can implement to import a site’s CSS/HTML into your design Canvas without leaking styles into the app UI and without inline styles.

High‑isolation architecture (recommended)

Option A — Shadow DOM (best mix of safety + performance)
Render the Canvas inside a Shadow Root and attach a constructed stylesheet that you rewrite on import.

Canvas host: <div id="canvas-host" /> → const root = host.attachShadow({ mode: 'open' })

Import pipeline rewrites the site’s CSS (details below) and loads it with root.adoptedStyleSheets = [sheet]

Shadow DOM blocks imported selectors from reaching your app; your app’s CSS can’t leak in either.

Special rewrites still needed for :root, html, body, keyframes, and URLs.

Option B — Iframe sandbox (max isolation, heavier)
Load the design DOM and rewritten CSS in an <iframe sandbox> with a minimal bridge (postMessage) for selection/drag/resize. Use if sites rely on UA defaults or odd global resets you don’t want to mimic.

Both options keep your UI classes (e.g. .container) safe from collisions.

CSS rewrite pipeline (works for Shadow DOM and Iframe)

You’ll run this once per import and cache the result in IndexedDB alongside the project.

Goals

Scope all selectors to the Canvas (even element/universal ones).

Avoid class name collisions (e.g., .container).

Preserve cascade and predictable specificity.

Rename keyframes and font-families to avoid global name clashes.

Sanitize dangerous at‑rules and imports.

1) Generate a unique Canvas scope
const canvasId = nanoid();              // e.g. "f3k9s1"
const SCOPE = `[data-canvas="${canvasId}"]`;


Wrap imported DOM with:

<div data-canvas="f3k9s1"> ... imported DOM ... </div>


(If using Shadow DOM, the wrapper still helps with :root/vars scoping and future copy/paste.)

2) Rewrite selectors with PostCSS

Use postcss, postcss-selector-parser, and postcss-value-parser.

Selector rule
Prefix every normal selector with your scope using :is() to keep inner specificity intact:

S becomes  `${SCOPE} :is(S)`


Examples:

.container → [data-canvas=f3k9s1] :is(.container)

header .nav > a:hover → [data-canvas=f3k9s1] :is(header .nav > a:hover)

* → [data-canvas=f3k9s1] :is(*)

Why :is and not :where?

:is() preserves the specificity of S (so imported CSS still behaves like on the original site).

If you want your editor’s overlay classes to always win, you can put the imported CSS into a lower cascade layer (see “Layers” below), or switch to :where() in a “low-priority” mode.

Special selectors

:root, html, body → replace with the scope itself:

:root, html, body → [data-canvas=f3k9s1]

:not(...) → rewrite its content with the same rules.

ID selectors are okay; they’ll be scoped by prefixing, so templates with #header won’t spill out.

At‑rules

@media/@supports: recurse into contained rules.

@keyframes NAME: rename to canvasId-NAME; update any animation/animation-name values accordingly.

@font-face: rename font-family to "canvasId-FONT" and rewrite any usages; inline or rewrite src: URLs (see Assets).

@import: either drop or inline; never allow network fetch at runtime from the imported stylesheet (security & determinism).

Assets and URLs

Turn relative URLs into project assets (store in IndexedDB; return blob/object URLs).

Optionally inline tiny assets as data URLs.

Sanitize

Drop @layer that attempts to elevate global styles. You control layering.

Disallow position: fixed outside the scope host if you don’t want escaping overlays. If needed, rewrite fixed → absolute and emulate via a positioned scope root.

Tiny PostCSS sketch (selector prefix)
import postcss from 'postcss';
import selectorParser from 'postcss-selector-parser';

function prefixSelectors(root: postcss.Root, scope: string) {
  root.walkRules(rule => {
    if (!rule.selectors) return;
    rule.selectors = rule.selectors.map((sel) => {
      if (sel.match(/^:root$|^html$|^body$/)) return scope;
      return `${scope} :is(${sel})`;
    });
  });
}


(You’ll also add keyframe/name rewrites and value parsing for animation/font-family.)

Optional: Class renaming (zero collision mode)

For maximum certainty, also rename classes in both HTML and CSS:
.container → .wda-f3k9s1_container

Traverse imported DOM and rewrite class tokens.

In CSS, use a selector parser to rename class nodes only (not tag/ID selectors).

This guarantees no conflict even if your app UI accidentally shares a class name injected into the Canvas (e.g., when mounting UI controls inside the same document).

This layer can be combined with the scope prefix for belt‑and‑suspenders isolation:

[scope] :is(.wda-f3k9s1_container)

Variables & resets

Replace :root { --var: ... } with [scope] { --var: ... }.
All descendants inherit vars correctly.

If the imported CSS includes global resets (e.g., html, body, * { ... }), they’re already scoped by the prefix and won’t touch your UI.

Provide a Canvas base stylesheet (your own) to normalize typography and box model inside the scope so the imported site has a predictable baseline.

Cascade layers (play nice with your editor)

Insert the entire imported CSS into a named, low‑priority layer:

@layer imported-site {
  /* prefixed, rewritten CSS here */
}


Place your editor/overlay styles in a higher layer:

@layer editor, ui, imported-site; /* order matters */


This way, selection boxes, resize handles, and drag targets always win the cascade without cranking specificity.

(If you use Shadow DOM, layers still work inside the shadow, just define your editor CSS in a sheet added after the imported sheet or in a higher layer.)

Rendering in React (Shadow DOM example)
// CanvasHost.tsx
import React, { useEffect, useRef } from 'react';

export function CanvasHost({ canvasId, htmlTree, cssText }: {
  canvasId: string;
  htmlTree: HTMLElement; // or serialized HTML you hydrate
  cssText: string;       // already rewritten
}) {
  const hostRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const host = hostRef.current!;
    const shadow = host.attachShadow({ mode: 'open' });

    // 1) Build canvas root wrapper
    const wrapper = document.createElement('div');
    wrapper.setAttribute('data-canvas', canvasId);
    wrapper.appendChild(htmlTree); // doc fragment of imported DOM

    // 2) Adopt rewritten stylesheet
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(cssText);
    shadow.adoptedStyleSheets = [sheet];

    // 3) Mount
    shadow.appendChild(wrapper);

    return () => { host.innerHTML = ''; };
  }, [canvasId, htmlTree, cssText]);

  return <div ref={hostRef} />;
}

Hit list of tricky edge cases (and what to do)

Absolute/fixed positioned overlays: optionally rewrite fixed to stay inside the Canvas bounds.

Z‑index wars: cap imported z-index to a range (e.g., clamp to 0–100) and put your editor at 1000+.

Keyframes/animations: rename keyframes and rewrite animation values; same for @counter-style if present.

Fonts: rename font-family, cache fonts, rewrite src:; avoid duplicate loads via a per‑asset hash.

SVG <style> blocks inside imported SVGs: run the same prefixer over them.

@import url(...): inline during processing; disallow at runtime.

url(#fragment) in SVG filters: leave as‑is (scoped by the DOM tree, not CSS).

Why not just CSS Modules or Tailwind prefixes?

CSS Modules rename class references but won’t catch tag/universal/ID selectors nor global targets (html, body) in third‑party CSS.

Tailwind’s prefix helps your classes but not their classes. You still need a scoper/prefixer for the imported CSS.

Minimal deliverables for the agent

postcss pipeline that:

Prefixes every selector to [data-canvas="ID"] :is(...)

Rewrites :root|html|body → [data-canvas="ID"]

Renames @keyframes + updates usages

Renames font-family in @font-face + updates usages

Inlines/dereferences @import and asset URLs

(Optional) Renames class tokens → wda-ID_className in both DOM & CSS

Renderer that:

Uses Shadow DOM and adoptedStyleSheets for isolation

Adds your editor sheet after the imported sheet (or in a higher @layer)

Wraps content in [data-canvas="ID"]

Safety:

Strip @import (runtime)

Sanitize dangerous URLs (javascript:, data: except vetted images/fonts)

Clamp z‑index, rewrite position: fixed if desired

This gives you deterministic, conflict‑free styling limited to the Canvas, with predictable specificity and zero bleed into your UI—even with gnarly third‑party styles.