Goal

Enable intuitive drag‑and‑drop reordering in the Element Tree so users can change the DOM order and hierarchy. Changes must reflect immediately on the Canvas and be fully undoable/redoable.

Scope

Applies to all canvas elements shown in the Element Tree, including component instances.

Excludes non-element nodes (e.g., pure text nodes).

Honors locks/visibility and component rules.

UX & Interaction Rules

Start drag

Drag can start from: row drag-handle or the whole row (except inline actions).

While dragging, show a “ghost” of the row under the cursor and keep the original in place until drop.

Targets & drop zones

Every visible row exposes up to three logical zones during drag:

Before (insert above)

Inside (nest as first child)

After (insert below)

Zone selection heuristics:

Top 30% = Before

Middle 40% = Inside

Bottom 30% = After

If target cannot accept children (invalid recipient), suppress Inside and default to Before/After.

If user drops “on” a row (not clearly top/bottom), resolve as:

Inside if the target is a valid recipient.

After if the target is not a valid recipient.

Valid recipients

Accepts children: container‑type elements (e.g., div, section, main, nav, header, footer, aside, article, generic container components, and any element with layout role container|flex|grid in our schema).

Special lists: ul/ol accept only li; li accepts block/inline per our existing schema.

Follow current schema constraints (no cycles, no invalid parent/child combos).

Visual feedback

Insertion line for Before/After with a full‑width hairline and subtle animation.

Highlight valid Inside targets with a rounded outline.

Invalid zones show a not‑allowed cursor and no insertion line.

While hovering a collapsed node, auto‑expand after 500 ms to expose children (and then allow Inside placement).

Auto‑scroll

If dragging near the top/bottom of the panel, auto‑scroll the tree.

If hovering a scrollable parent in the Canvas (optional), do not scroll Canvas—tree only.

Drop behavior

On drop, move the element to the resolved position:

Before/After → same parent as target, index adjusted.

Inside → become first child of target (index 0).

Do not change selection; keep the dragged element selected after move.

Keyboard accessibility

Focused row: Space toggles “reorder mode”.

In reorder mode: ArrowUp/ArrowDown moves Before/After; ArrowRight tries Inside, ArrowLeft outdents to parent’s After.

Enter to confirm; Esc to cancel.

Announce moves via aria-live (“Moved Button after Header”).

Undo/Redo

Each completed drop (or keyboard confirm) = one atomic history step.

Works with persistent history across sessions.

State, Data & Actions (Redux)

Selectors

selectTreeNodes() → linearized tree with ids, parentId, index, acceptsChildren flag, allowedChildTypes.

selectIsDroppable(sourceId, targetId, zone) → schema‑aware validation.

Actions

startDrag({sourceId})

updateDragHover({targetId, zone})

commitDrag({sourceId, targetId, zone}) → performs move if valid; no‑op if invalid.

cancelDrag()

Mutation

moveNode({nodeId, newParentId, newIndex})

Synchronously update:

DOM model in store (the canonical tree)

Canvas rendering order (see Integration below)

Selection stays on nodeId

Validation guardrails

Reject if:

nodeId === targetId

Target is a descendant of source (no cycles)

Target zone violates schema (e.g., li into div if disallowed)

Target or source is locked

Derive newParentId/newIndex from (targetId, zone) with stable rules.

Canvas Integration (Immediate Reflection)

Canvas listens to the same canonical tree (Redux). When moveNode fires:

Recompute child arrays for impacted parents.

Rerender only affected subtrees (memoized components, keyed by element id).

Maintain per‑instance preserved properties (per Components system).

If an element is isolated in Component Edit mode:

Allow moves within the component’s local tree only.

Forbid moves across component boundaries unless detaching (not part of this task).

Component Instance Rules

Component Instance (read‑only) can be moved as a unit (Before/After relative to siblings).

You cannot drop Inside a component instance unless its definition explicitly exposes a slot/child region.

Propagation/versioning unaffected by reorder.

Edge Cases

Hidden elements: visible in tree if “show hidden” is on; can be moved; Canvas updates regardless of hidden state.

Locked elements: visible but not draggable; show lock icon and suppress drop zones on them.

Cross‑frame constraints: Cannot move nodes into different “root documents” (e.g., artboards/pages) in this task.

Lists (ul/ol): dropping non‑li resolves to Before/After; Inside invalid unless source is li.

Self-descendant: prevent by precomputed ancestor set during drag.

Out-of-bounds index: clamp to [0..children.length].

Performance

Throttle updateDragHover to ~60–100ms.

Compute droppable state with cached schema checks.

Virtualize tree if >1,000 nodes; keep drag overlays outside virtualization layer.

Accessibility (WCAG 2.1)

All drag affordances reachable by keyboard (see Keyboard section).

ARIA:

Tree uses role="tree", rows as role="treeitem" with aria-level, aria-expanded.

Live region for move announcements (aria-live="polite").

Drag state announced (aria-grabbed, aria-dropeffect" where applicable).

Contrast and focus outlines consistent with existing UI.

Telemetry (optional)

Log: startDrag, drop (success/invalid), keyboardReorder, autoExpand.

Include counts and durations for UX tuning.

QA / Acceptance Criteria

Immediate reflection: After drop, Canvas order matches Element Tree without manual refresh.

Inside vs After: Dropping “on” a valid recipient nests as first child; dropping “on” an invalid recipient places after.

Visual feedback: Insertion line and highlight appear only for valid zones.

Schema enforcement: Illegal parent/child combos are blocked.

No cycles: Cannot drop a node into its own subtree.

Undo/Redo: One undo reverts the entire move; redo reapplies it.

Locks respected: Locked nodes cannot be dragged; cannot drop Inside them if they forbid children.

Auto‑expand: Collapsed nodes expand on hover during drag and accept Inside drops.

Keyboard parity: All moves possible via keyboard; screen reader announces moves.

Component instances: Move as a unit; cannot drop Inside unless the slot is exposed.

Implementation Notes

Keep all calculations pure inside reducers/selectors; DOM/Canvas updates happen via React render after state change.

Provide a single utility: resolveDrop({sourceId, targetId, zone}) -> {newParentId, newIndex} | null

Write deterministic tests for:

Before/After/Inside mapping,

List semantics (ul/ol),

Component boundaries,

Undo/redo,

Accessibility announcements.